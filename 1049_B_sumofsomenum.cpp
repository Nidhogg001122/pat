#include<cstdio>
using namespace std;

double num[100010];

int main() {
	int n, i;
	scanf("%d", &n);
	for (i = 0; i < n; i++) scanf("%lf", &num[i]);
	long long sum = 0;
	/*使用三重循环必定超时，对于序列[0.1,0.2,0.3,0.4],片段为
	* (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4)
	* (0.2) (0.2, 0.3) (0.2, 0.3, 0.4)
	* (0.3) (0.3, 0.4)
	* (0.4)
	* 对于层状结构，我们发现对于第i个数，它会出现在i+1层(因为是从0开始计数，若从1开始则i);
	* 每层出现为n-i次，即只有大于或等于它的数出现时它才有可能出现；
	* 故每个数出现次数(i+1)*(n-i);
	for (i = 0; i < n; i++) {
		for (j = 0; j < n - i; j++) {
			for (k = 0; k <= j; k++) sum += num[i + k];
		}
	}
	*/
	for (i = 0; i < n; i++) sum += (long long)(num[i] * 1000.0) * (i + 1) * (n - i);
	/*
	* 补充一点，我个人觉得这题非常恶心，对于浮点数，在n极大的时候由于精度的问题会产生误差
	* 在测试集中，测试点三明显就是冲着这个目的设置的
	* 在此处的解决方法是将求和的sum扩大，在计算时成一个大整数使小数点偏移，避免最后结果的误差
	*/
	printf("%.2f\n", sum / 1000.0);
	return 0;
}